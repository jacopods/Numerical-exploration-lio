# -*- org-src-preserve-indentation: t -*-
#+title: The spectrum of Linearized Isospectral operators
#+author: Jacopo De Simoi + Robert Westhaver

* Intro
* The main library: ~domain~
:PROPERTIES:
:header-args: :tangle domain.py
:END:

In this section we create the ~Domain~ class, which will be
responsible for containing and processing information about each
domain.
#+begin_src python
import math
import numpy as np
import matplotlib.pyplot as plt
#+end_src

The constructor of the class loads a file and parses its content.
The file –for now– is one line of tilde-separated list of pairs a,b,
where

- $a$ is the list of coefficients of the $sin$ Fourier modes of the
  curvature radius
- $b$ is the list of coefficients of the $cos$ Fourier modes of the
  curvature radius

In other words, the curvature radius $ρ$ as a function of the tangent
angle $θ$ is given by:

$$ ρ(θ) = \sum_{k=0}^∞ a_k \sin(kθ) + b_k \cos(kθ) $$

#+begin_src python
class Domain:
    def __init__(self, fname):
        with open(fname) as fp:
            for line in fp:
                line = line.strip()
                self.pairs = line.split('~')
                self.ρ_Fourier_coefficients = [list(map(float,pair.split(','))) for pair in self.pairs]
#+end_src

- TODO Modify the code to accept a json file, instead

It would be then easy to store (cache) further information about the
 domain should we want to.

Now we define a method to return the curvature function
#+begin_src python
    def ρ(self,θ):
        pt = 0
        n = 0
        for a,b in self.ρ_Fourier_coefficients:
            pt += ((a * np.sin(n*θ)) + (b * np.cos(n*θ)))
            n += 1
        return pt
#+end_src

And we define a method γ to return the point parametrized by θ:
#+begin_src python
    def γ(self, θ):
        x_a_sum = 0
        x_b_sum = 0
        y_a_sum = 0
        y_b_sum = 0
        for k in range(2, len(self.ρ_Fourier_coefficients),1):
            a,b = self.ρ_Fourier_coefficients[k]
            x_a_sum += (a/2) * (((1 - (np.cos((k+1)*θ))) / (k + 1)) + ((1 - (np.cos((k - 1)*θ))) / (k - 1)))
            x_b_sum += (b/2) * (((np.sin((k+1)*θ)) / (k + 1)) + ((np.sin((k - 1)*θ)) / (k - 1)))
            y_a_sum += (a/2) * (-(((np.sin((k+1)*θ))) / (k + 1)) + (((np.sin((k - 1)*θ))) / (k - 1)))
            y_b_sum += (b/2) * (((1 - (np.cos((k+1)*θ))) / (k + 1)) + (((np.cos((k - 1)*θ)) - 1) / (k - 1)))
        x= x_a_sum + x_b_sum + (self.ρ_Fourier_coefficients[0][1] * np.sin(θ))
        y= y_a_sum + y_b_sum + (self.ρ_Fourier_coefficients[0][1] * (1-np.cos(θ))
)
        return x,y
#+end_src

Now, just for fun, we add a method for plotting the domain
#+begin_src python
    def plot(self):
        ep = math.pi/100

        #adding epsilon will add 1 last point which ends up near the beginning point of graph
        γ_list = [ γ(self, theta) for theta in np.arange(0,(2*math.pi)+ep,ep)]
        plt.axes().set_aspect('equal')
        plt.plot(list(zip(*γ_list))
        plt.show()

#+end_src
