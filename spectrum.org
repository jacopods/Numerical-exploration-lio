# -*- org-src-preserve-indentation: t -*-
#+title: The spectrum of Linearized Isospectral operators
#+author: Jacopo De Simoi + Robert Westhaver

* Intro
* Note on notation:
  We will generally denote scalars with lowercase letters (e.g. θ, x)
  and vectors with capital letters (e.g. Θ, X)
* The main library: ~domain~
:PROPERTIES:
:header-args: :tangle domain.py
:END:

In this section we create the ~Domain~ class, which will be
responsible for containing and processing information about each
domain.
#+begin_src python
import math
import numpy as np
import matplotlib.pyplot as plt
from scipy import optimize as optimize
from scipy import integrate as integrate
#+end_src

The constructor of the class loads a file and parses its content.
The file –for now– is one line of tilde-separated list of pairs a,b,
where

- $a$ is the list of coefficients of the $sin$ Fourier modes of the
  curvature radius
- $b$ is the list of coefficients of the $cos$ Fourier modes of the
  curvature radius

In other words, the curvature radius $ρ$ as a function of the tangent
angle $θ$ is given by:

$$ ρ(θ) = \sum_{k=0}^∞ a_k \sin(kθ) + b_k \cos(kθ) $$

For the time being, we are working under the assumption that the
domain is ℤ₂-symmetric, hence we throw an exception if this is not the
case.

#+begin_src python
class Domain:
    def __init__(self, fname):
        with open(fname) as fp:
            for line in fp:
                line = line.strip()
                self.pairs = line.split('~')
                self.ρ_Fourier_coefficients = [list(map(float,pair.split(','))) for pair in self.pairs]

        # For now, throw an exception if the domain is not symmetric
        if (not self.is_symmetric()):
            raise Exception('The domain is not ℤ₂-symmetric; routines have not yet been implemented in this case')

        # Select the appropriate methods depending on the symmetry
        # properties
        if (self.is_symmetric()):
            self.ρ = self._ρ_symmetric
            self.γ = self._γ_symmetric
        else:
            self.ρ = self._ρ_generic
            self.γ = self._γ_generic

        self.Lazutkin_perimeter = self.raw_Lazutkin(2*math.pi)
#+end_src

- TODO Modify the code to accept a json file, instead

It would be then easy to store (cache) further information about the
 domain should we want to.

** Basic methods

We define a method to check the symmetry of the domain.
Recall that a domain is ℤ₂-symmetric if the $a$-coefficients are all 0.
#+begin_src python
    def is_symmetric(self):
        return all([ (a == 0) for a,b in self.ρ_Fourier_coefficients])
#+end_src

We define a method to return the curvature function computed at
the tangent angle; we provide a slightly optimized version for
symmetric domains
#+begin_src python
    def _ρ_generic(self,θ):
        pt = 0
        n = 0
        for a,b in self.ρ_Fourier_coefficients:
            pt += ((a * np.sin(n*θ)) + (b * np.cos(n*θ)))
            n += 1
        return pt

    def _ρ_symmetric(self,θ):
        pt = 0
        n = 0
        for _,b in self.ρ_Fourier_coefficients:
            pt += b * np.cos(n*θ)
            n += 1
        return pt
#+end_src

Next, we define a method γ which returns the point parametrized by θ:
#+begin_src python
    def _γ_generic(self, θ):
        x = self.ρ_Fourier_coefficients[0][1] * np.sin(θ)
        y = self.ρ_Fourier_coefficients[0][1] * (1-np.cos(θ))

        for k in range(2, len(self.ρ_Fourier_coefficients),1):
            a,b = self.ρ_Fourier_coefficients[k]
            x += ((a/2) * (((1 - (np.cos((k + 1)*θ))) / (k + 1)) +
                           ((1 - (np.cos((k - 1)*θ))) / (k - 1))) +
                  (b/2) * (((np.sin((k + 1)*θ)) / (k + 1)) +
                           ((np.sin((k - 1)*θ)) / (k - 1))))
            y += ((a/2) * (-((np.sin((k + 1)*θ)) / (k + 1)) +
                            ((np.sin((k - 1)*θ)) / (k - 1))) +
                  (b/2) * (((1 - (np.cos((k + 1)*θ))) / (k + 1)) +
                           (((np.cos((k - 1)*θ)) - 1) / (k - 1))))
        return x,y

    def _γ_symmetric(self, θ):
        x = self.ρ_Fourier_coefficients[0][1] * np.sin(θ)
        y = self.ρ_Fourier_coefficients[0][1] * (1-np.cos(θ))

        for k in range(2, len(self.ρ_Fourier_coefficients),1):
            _,b = self.ρ_Fourier_coefficients[k]
            x += ((b/2) * (((np.sin((k + 1)*θ)) / (k + 1)) +
                           ((np.sin((k - 1)*θ)) / (k - 1))))
            y += ((b/2) * (((1 - (np.cos((k + 1)*θ))) / (k + 1)) +
                           (((np.cos((k - 1)*θ)) - 1) / (k - 1))))

        return x,y
#+end_src

We then define the L method, which returns the length of the polygon
inscribed in the domain whose vertices are identified by the list of
θ's given as parameter.
#+begin_src python
    # this returns the q-length function
    def L(self, Θ):
        summation = 0
        q=len(Θ)
        P=list(map(self.γ,Θ))
        for j in range(q):
            summation += (math.sqrt((P[(j+1) % q][0] - P[j][0])**2 +
                                    (P[(j+1) % q][1] - P[j][1])**2))
        return summation
#+end_src

Define the gradient of the L function
#+begin_src python
    def _calc_dLq_in_dθ(self, p, θ, k):
        q = len(p)

        Δx0 = (p[k][0] - p[(k-1)%q][0])
        Δy0 = (p[k][1] - p[(k-1)%q][1])
        ℓ0 = math.sqrt(Δx0**2+Δy0**2)

        Δx1 = (p[(k+1)%q][0] - p[k][0])
        Δy1 = (p[(k+1)%q][1] - p[k][1])
        ℓ1 = math.sqrt(Δx1**2+Δy1**2)

        cosθ = np.cos(θ[k])
        sinθ = np.sin(θ[k])

        return self.ρ(θ[k]) * ((Δx0*cosθ+Δy0*sinθ)/ℓ0 - (Δx1*cosθ+Δy1*sinθ)/ℓ1)

    # This is the gradient of the q-length function.

    # TODO: we can still
    # optimize by perhaps a factor 2 by re-using the displacements.  At the moment they are computed twice (once for each adjacent vertex.)
    def gradient_L(self, Θ):
        q = len(Θ)
        P = list(map(self.γ, Θ))

        return np.array([self._calc_dLq_in_dθ(P, Θ, k) for k in range(q)])
#+end_src


This method evaluates the k-th (even) Fourier mode at θ
#+begin_src python
    # This evaluates the k-th Fourier mode at θ
    def  e_k(self, θ, k):
        return np.cos(k * (2 * math.pi * self.Lazutkin(θ)))
#+end_src

** Novelty methods

Now, just for fun, we add a method for plotting the domain
#+begin_src python
    def plot(self):
        ε = math.pi/100

        #adding epsilon will add 1 last point which ends up near the beginning point of graph
        γ_list = [ self.γ(θ) for θ in np.arange(0,(2*math.pi)+ε , ε)]
        plt.axes().set_aspect('equal')
        x_l,y_l=list(zip(*γ_list))
        plt.plot(x_l,y_l)
#+end_src

** Lazutkin parametrization

Now we add methods for computing the Lazutkin coordinates (and
inverting the Lazutkin coordinates).  Our implementation shows that
in the computation of the elements of each row, the gradient
optimization is taking the bulk of the time, so it makes sense to
optimize the choice of initial conditions.

#+begin_src python
    def raw_Lazutkin(self,θ):
        # This returns the un-normalized Lazutkin parametrization at θ
        return integrate.quad(lambda t: self.ρ(t)**(1/3), 0, θ)[0]

    def Lazutkin(self,θ):
        return self.raw_Lazutkin(θ)/self.Lazutkin_perimeter;

    # implement inverse lazutkin
    def inverse_Lazutkin(self, x):
        return optimize.newton(
            lambda t: self.Lazutkin(t)-x,
            2*math.pi*x,
            lambda t: (self.ρ(t)**(1/3)/self.Lazutkin_perimeter))
#+end_src

** Periodic orbits

In this section we define methods to compute and retrieve periodic
orbits.

*Note*: at the moment we offer a method to find the maximal orbit
(i.e. orbit of maximal length) in the unconstrained case

#+begin_src python
    def maximal_orbit(self,q):
        # guess initial conditions to be equispaced in Lazutkin coords
        Θ_guess=[self.inverse_Lazutkin(x) for x in np.arange(0,1,1/q)]

        # find the orbit of rotation number 1/q
        res = optimize.minimize(lambda Θ:-self.L(Θ),
                                Θ_guess,
                                method = 'CG',
                                jac = lambda Θp:-self.gradient_L(Θp))
        if (not res.success):
            print(res)
        return res["x"]
#+end_src
