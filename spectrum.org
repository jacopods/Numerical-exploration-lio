# -*- org-src-preserve-indentation: t -*-
#+title: The spectrum of Linearized Isospectral operators
#+author: Jacopo De Simoi + Robert Westhaver

* Intro
* The main library: ~domain~
:PROPERTIES:
:header-args: :tangle domain.py
:END:

In this section we create the ~Domain~ class, which will be
responsible for containing and processing information about each
domain.
#+begin_src python
import math
import numpy as np
import matplotlib.pyplot as plt
#+end_src

The constructor of the class loads a file and parses its content.
The file –for now– is one line of tilde-separated list of pairs a,b,
where

- $a$ is the list of coefficients of the $sin$ Fourier modes of the
  curvature radius
- $b$ is the list of coefficients of the $cos$ Fourier modes of the
  curvature radius

In other words, the curvature radius $ρ$ as a function of the tangent
angle $θ$ is given by:

$$ ρ(θ) = \sum_{k=0}^∞ a_k \sin(kθ) + b_k \cos(kθ) $$

#+begin_src python
class Domain:
    def __init__(self, fname):
        with open(fname) as fp:
            for line in fp:
                line = line.strip()
                self.pairs = line.split('~')
                self.ρ_Fourier_coefficients = [list(map(float,pair.split(','))) for pair in self.pairs]
#+end_src

- TODO Modify the code to accept a json file, instead

It would be then easy to store (cache) further information about the
 domain should we want to.

Now we define a method to return the curvature function
#+begin_src python
    def ρ(self,θ):
        pt = 0
        n = 0
        for a,b in self.ρ_Fourier_coefficients:
            pt += ((a * np.sin(n*θ)) + (b * np.cos(n*θ)))
            n += 1
        return pt
#+end_src

And we define a method γ to return the point parametrized by θ:
#+begin_src python
    def γ(self, θ):
        x = self.ρ_Fourier_coefficients[0][1] * np.sin(θ)
        y = self.ρ_Fourier_coefficients[0][1] * (1-np.cos(θ))

        for k in range(2, len(self.ρ_Fourier_coefficients),1):
            a,b = self.ρ_Fourier_coefficients[k]
            x += ((a/2) * (((1 - (np.cos((k+1)*θ))) / (k + 1)) +
                           ((1 - (np.cos((k - 1)*θ))) / (k - 1))) +
                  (b/2) * (((np.sin((k+1)*θ)) / (k + 1)) +
                           ((np.sin((k - 1)*θ)) / (k - 1))))
            y += ((a/2) * (-((np.sin((k+1)*θ)) / (k + 1)) +
                           ((np.sin((k - 1)*θ)) / (k - 1))) +
                  (b/2) * (((1 - (np.cos((k+1)*θ))) / (k + 1)) +
                           (((np.cos((k - 1)*θ)) - 1) / (k - 1))))
        return x,y
#+end_src

Now, just for fun, we add a method for plotting the domain
#+begin_src python
    def plot(self):
        ε = math.pi/100

        #adding epsilon will add 1 last point which ends up near the beginning point of graph
        γ_list = [ self.γ(θ) for θ in np.arange(0,(2*math.pi)+ε , ε)]
        plt.axes().set_aspect('equal')
        x_l,y_l=list(zip(*γ_list))
        plt.plot(x_l,y_l)
        plt.show()
#+end_src
