# -*- org-src-preserve-indentation: t -*-
#+title: The spectrum of Linearized Isospectral operators
#+author: Jacopo De Simoi + Robert Westhaver

* Intro
* The main library: ~domain~
:PROPERTIES:
:header-args: :tangle domain.py
:END:

In this section we create the ~Domain~ class, which will be
responsible for containing and processing information about each
domain.
#+begin_src python
import math
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
#+end_src

The constructor of the class loads a file and parses its content.
The file –for now– is one line of tilde-separated list of pairs a,b,
where

- $a$ is the list of coefficients of the $sin$ Fourier modes of the
  curvature radius
- $b$ is the list of coefficients of the $cos$ Fourier modes of the
  curvature radius

In other words, the curvature radius $ρ$ as a function of the tangent
angle $θ$ is given by:

$$ ρ(θ) = \sum_{k=0}^∞ a_k \sin(kθ) + b_k \cos(kθ) $$

#+begin_src python
class Domain:
    def __init__(self, fname):
        with open(fname) as fp:
            for line in fp:
                line = line.strip()
                self.pairs = line.split('~')
                self.ρ_Fourier_coefficients = [list(map(float,pair.split(','))) for pair in self.pairs]
        self.Lazutkin_perimeter = self.raw_Lazutkin(2*math.pi)

#+end_src

- TODO Modify the code to accept a json file, instead

It would be then easy to store (cache) further information about the
 domain should we want to.

Now we define a method to return the curvature function
#+begin_src python
    def ρ(self,θ):
        pt = 0
        n = 0
        for a,b in self.ρ_Fourier_coefficients:
            pt += ((a * np.sin(n*θ)) + (b * np.cos(n*θ)))
            n += 1
        return pt
#+end_src

And we define a method γ to return the point parametrized by θ:
#+begin_src python
    def γ(self, θ):
        x = self.ρ_Fourier_coefficients[0][1] * np.sin(θ)
        y = self.ρ_Fourier_coefficients[0][1] * (1-np.cos(θ))

        for k in range(2, len(self.ρ_Fourier_coefficients),1):
            a,b = self.ρ_Fourier_coefficients[k]
            x += ((a/2) * (((1 - (np.cos((k + 1)*θ))) / (k + 1)) +
                           ((1 - (np.cos((k - 1)*θ))) / (k - 1))) +
                  (b/2) * (((np.sin((k + 1)*θ)) / (k + 1)) +
                           ((np.sin((k - 1)*θ)) / (k - 1))))
            y += ((a/2) * (-((np.sin((k + 1)*θ)) / (k + 1)) +
                            ((np.sin((k - 1)*θ)) / (k - 1))) +
                  (b/2) * (((1 - (np.cos((k + 1)*θ))) / (k + 1)) +
                           (((np.cos((k - 1)*θ)) - 1) / (k - 1))))
        return x,y
#+end_src

Now, just for fun, we add a method for plotting the domain
#+begin_src python
    def plot(self):
        ε = math.pi/100

        #adding epsilon will add 1 last point which ends up near the beginning point of graph
        γ_list = [ self.γ(θ) for θ in np.arange(0,(2*math.pi)+ε , ε)]
        plt.axes().set_aspect('equal')
        x_l,y_l=list(zip(*γ_list))
        plt.plot(x_l,y_l)
        plt.show()
#+end_src

Now we add methods for computing the Lazutkin coordinates (and
inverting the Lazutkin coordinates).  Our implementation shows that
in the computation of the elements of each row, the gradient
optimization is taking the bulk of the time, so it makes sense to
optimize the choice of initial conditions.

#+begin_src python
    def raw_Lazutkin(self,θ):
        # This returns the un-normalized Lazutkin parametrization at θ
        return sp.integrate.quad(lambda t: self.ρ(t)**(1/3), 0, θ)[0]

    def Lazutkin(self,θ):
        return self.raw_Lazutkin(θ)/self.Lazutkin_perimeter;

    # implement inverse lazutkin
#+end_src
